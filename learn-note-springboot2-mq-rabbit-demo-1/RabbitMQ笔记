======================================================================================================================
================           生产端        ==================================           消费端        ==================
======================================================================================================================
5种队列形式
	点对点（简单队列）
	工作（公平性）队列  ==>能者多劳   原理：必须用手动应答模式，队列服务器必须要收到消费者发送的ASK结果通知，才会继续发送下一个消息（谁应答快，谁就能多消费）
	发布订阅
	路由routing
	通配符topics
	
	
消费者集群，消费者默认均摊消费											String queue		队列名称
															boolean autoAck		true 自动应答模式	--》不在乎消费者对这个消息处理是否成功，都会告诉队列删除消息。
																				false手动应答		--》消费处理完业务逻辑，手动返回ACK （通知）告诉队列服务器是否删除该消息
															Consumer callback	
															channel.basicConsume(QUEUE_NAME, true, defaultConsumer);

===========================================================================================
工作（公平性）队列
channel.basicQos(1);										channel.basicConsume(QUEUE_NAME, false, defaultConsumer);



发布订阅
	结构：
		producer exchange queue consumer
	思路解读（重点理解）：
		1、一个生产者，多个消费者
		2、每一个消费者都有自己的一个队列
		3、生产者没有直接发消息到队列中，而是发送到交换机
		4、每个消费者的队列都绑定到交换机上
		5、消息通过交换机到达每个消费者的队列
		该模式就是Fanout Exchange（扇形交换机）将消息路由给绑定到它身上的所有队列
		注意：交换机没有储存消息功能，如果消息发送到没有绑定消费队列的交换机，消息则丢失
		消费者没有启动，会自动缓存，activemq不会
	交换机类型：
		Direct exchange（直连交换机）是根据消息携带的路由键（routing key）将消息投递给对应的队列
		Fanout exchange（扇形交换机）将消息路由给绑定到它身上的所有队列
		Topic exchange（主题交换机）队列通过路由建绑定到交换机上，然后交换机根据消息里的路由键，将消息路由给一个或多个绑定队列
		Headers exchange（头交换机）类似主题交换机，但是头交换机使用多个消息属性来代替路由键建立路由规则
		

================================================================================================
消息确认机制
	生产者发送消息出去后，不知道到底是否成功发送到Rabbitmq服务器上
	解决方案：
		1、AMQP 事物机制
		2、Comfirm 模式
	事物模式：
		txSelect 将当前channel设置为transaction模式
		txCommit 提交当前事务
		txRollback 事务回滚
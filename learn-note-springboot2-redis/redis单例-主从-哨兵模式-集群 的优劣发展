摘自：https://blog.csdn.net/keketrtr/article/details/78802571


1、单例
	配置好单个redis之后，可以在redis中执行相关命令来操作数据

	但是将数据完全存储在单个redis中主要存在两个问题：数据备份和数据体量较大造成的性能降低。
	
2、redis的主从模式
	这里redis的主从模式为这两个问题提供了一个较好的解决方案
	主从模式指的是使用一个redis实例作为主机，其余的实例作为备份机。主机和从机的数据完全一致，【主机支持数据的【写入】和【读取】】等各项操作，而【从机则只支持与主机数据的同步和读取】
	
	bind 127.0.0.1
	port 6379
	logfile "6379.log"
	dbfilename "dump-6379.rdb"
	
	bind 127.0.0.1
	port 6380
	logfile "6380.log"
	dbfilename "dump-6380.rdb"
	slaveof 127.0.0.1 6379
	
	redis主从模式解决了数据备份和单例可能存在的性能问题，但是其也引入了新的问题。
	由于主从模式配置了三个redis实例，并且每个实例都使用不同的ip（如果在不同的机器上）和端口号，
	根据前面所述，主从模式下可以将读写操作分配给不同的实例进行从而达到提高系统吞吐量的目的，但也正是因为这种方式造成了使用上的不便，因为每个客户端连接redis实例的时候都是指定了ip和端口号的，如果所连接的redis实例因为故障下线了，而主从模式也没有提供一定的手段通知客户端另外可连接的客户端地址，因而需要手动更改客户端配置重新连接。
	另外，主从模式下，如果主节点由于故障下线了，那么从节点因为没有主节点而同步中断，因而需要人工进行故障转移工作。
	
	注意：Redis什么时候不可用
	a:如果集群任意master挂掉,且当前master没有slave.集群进入fail状态,也可以理解成集群的slot映射[0-16383]不完成时进入fail状态. 
	b:如果集群超过半数以上master挂掉，无论是否有slave集群进入fail状态.
	
3、sentinel（哨兵）架构
	为了解决主从模式下主节点的故障转移工作，在2.8版本之后redis正式提供了sentinel（哨兵）架构
	
	每个sentinel节点其实就是一个redis实例，与主从节点不同的是sentinel节点作用是用于监控redis数据节点的
	而sentinel节点集合则表示监控一组主从redis实例多个sentinel监控节点的集合
	
4、redis集群的配置
	redis集群是在redis 3.0版本推出的一个功能，并发和流量瓶颈等问题时，可采用Cluster方案达到负载均衡的目的。
	redis中sentinel有效的解决了故障转移的问题，也解决了主节点下线客户端无法识别新的可用节点的问题
	如果是从节点下线了，sentinel是不会对其进行故障转移的，并且连接从节点的客户端也无法获取到新的可用从节点，而这些问题在Cluster中都得到了有效的解决。

	
	redis集群怎么做到高可用：
		redis集群中数据是和槽（slot）挂钩的，其总共定义了16384个槽，所有的数据根据一致哈希算法会被映射到这16384个槽中的某个槽中；另一方面，这16384个槽是按照设置被分配到不同的redis节点上的，
		比如启动了三个redis实例：cluster-A，cluster-B和cluster-C，
			将	0-5460号槽		分配给cluster-A
			将	5461-10922号槽	分配给cluster-B
			将	10923-16383号槽	分配给cluster-C
		（总共有16384个槽，但是其标号类似数组下标，是从0到16383）。
		也就是说数据的存储只和槽有关，并且槽的数量是一定的，由于一致hash算法是一定的，因而将这16384个槽分配给无论多少个redis实例，对于确认的数据其都将被分配到确定的槽位上。redis集群通过这种方式来达到redis的高效和高可用性目的。

	补充说明为什么集群16384个槽
		一致哈希算法根据数据的key值计算得到值有16位，可以产生2^16-=65536个值。换句话说，值是分布在0~65535之间,但是作者用16384做取模运算，而没用65536。最主要是集群之间会发送心跳包，65536个槽位导致请求数据包过大，斟酌取了16384，不多不少
		